// Generated by CoffeeScript 1.4.0
(function() {
  var BufferStream, EventEmitter, LiteTouch, Socket, acknowlegements, hex, pad,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  BufferStream = require('bufferstream');

  EventEmitter = require('events').EventEmitter;

  Socket = require('net').Socket;

  acknowlegements = ['RSACK', 'RCACK', 'RQRES'];

  hex = function(num) {
    return pad(num.toString(16).toUpperCase());
  };

  pad = function(num) {
    num = num.toString();
    while (num.length < 3) {
      num = "0" + num;
    }
    return num;
  };

  LiteTouch = (function(_super) {
    var astroTimeRegex, localTimeRegex, sunriseRegex, sunsetRegex;

    __extends(LiteTouch, _super);

    function LiteTouch(socket) {
      var _this = this;
      this.socket = socket;
      this.handleData = __bind(this.handleData, this);

      this.buffer = new BufferStream({
        encoding: 'utf8',
        size: 'flexible'
      });
      this.buffer.split('\r', function(message) {
        return _this.handleMessage(message.toString('ascii'));
      });
      this.socket.on('data', this.handleData);
    }

    /*
      Internal: Handle a chunk of data sent by the LiteTouch controller by writing it to the buffer.
    */


    LiteTouch.prototype.handleData = function(data) {
      return this.buffer.write(data.toString('ascii'));
    };

    /*
      Internal: A message has been received and must be handled. Messages acknowledging a command or responding to
      a query are emitted with the command as the event name and the additional payload as the event contents. Messages
      announching an event notification, LED update, or module update are also emitted.
    
      msg: String message sent by the LiteTouch controller.
    */


    LiteTouch.prototype.handleMessage = function(msg) {
      var cmd, parts, type;
      parts = msg.split(',');
      parts.shift();
      type = parts.shift();
      cmd = parts.shift();
      if (__indexOf.call(acknowlegements, type) >= 0) {
        return this.emit(cmd, parts);
      } else if (type === 'REVNT') {
        return handleEventNotification(cmd, parts);
      } else if (type === 'RLEDU') {
        return handleLEDUpdateNotification(cmd, parts);
      } else if (type === 'RMODU') {
        return handleModuleUpdateNotification(cmd, parts);
      }
    };

    /*
      Internal: An event notfication has been sent by the LiteTouch controller. Convert the notification into
      an emitted event.
    
      Switch notifications result in a press, release, or hold event for the station and button. Button numbers
      are 1-based, so the first switch is numbered 1, the second is numbered 2, and so forth.
    
      Example node.js event names for "event notifications":
    
        press:2,5   => switch #5 on station #2 was pressed
        release:2,5 => switch #5 on station #2 was released
        hold:3,1    => switch #1 on station #2 was held
    */


    LiteTouch.prototype.handleEventNotification = function(cmd, parts) {
      var button, station;
      if (cmd === 'SWP' || cmd === 'SWR' || cmd === 'SWH') {
        cmd = cmd === 'SWP' ? 'press' : cmd === 'SWR' ? 'release' : cmd === 'SWH' ? 'hold' : void 0;
        station = parseInt(parts[0].substr(0, 3));
        button = parseInt(parts[0].substr(2, 1));
        return this.emit("" + cmd + ":" + station + "," + button);
      } else if (cmd === 'TMB' || cmd === 'TME') {
        return this.emit("timer:" + parts[0]);
      } else if (cmd === 'USR') {
        return this.emit("user:" + parts[0]);
      }
    };

    /*
      Internal: An LED update notification has been sent by the LiteTouch controller. Convert the notification
      into an emitted event.
    
      LED update notifications for a station result in an led event for the station with an Array of Booleans describing
      the whether the LED of each switch is on.
    
      Example node.js events for LED notifications:
    
        led:5, [false,true,false,false,true,false,false,false,false,false,false,false,false,false,false] 
          => LEDs on station 5 were updated. LEDs on switch 2 and 5 are on. 
        
        led:1, [true,true,false,false,false,false,false,false,false,false,false,false,false,false,false]
          => LEDs on station 1 were updated. LEDS on switch 1 and 2 are on.
    */


    LiteTouch.prototype.handleLEDUpdateNotification = function(cmd, parts) {
      var bitmap, station;
      station = parseInt(cmd);
      bitmap = parts.shift().split('').map(function(bit) {
        return bit === '1';
      });
      return this.emit("led:" + station, bitmap);
    };

    /*
      Internal: A module update notification has been sent by the LiteTouch controller. Convert the notification
      into an emitted event.
    
      Module update notification indicate that loads have changed levels (lights were dimmed, turned on or off, etc).
      These notifications for a module result in a loads event for the module with an Array of Integers describing
      the current percentage level of loads attached to the module.
    
      Loads that have not changed levels are represented in the Array with a null value.
    
      Example node.js event for a module update:
    
        loads:5, [0,100,30,null,10,null,30,null]
          => Load state has chnaged on module 5. Load 1 is off. Load 2, 3, 5, and 6 are at 100%, 30%, 10% and 30% respectively.
             Load 4, 6, and 8 did not change levels.
    */


    LiteTouch.prototype.handleModuleUpdateNotification = function(cmd, parts) {
      var changed, levels, module;
      module = parseInt(cmd, 16);
      changed = parseInt(parts.shift(), 16).toString(2).split('');
      changed = changed.map(function(bit) {
        return bit === '1';
      });
      levels = parts.map(function(level) {
        if (level === '-1') {
          return null;
        } else {
          return parseInt(level);
        }
      });
      return this.emit("loads:" + module, levels);
    };

    /*
      Internal: Send a command to the LiteTouch controller.
    
      cmd: String command to send (i.e. SIEVN)
      args: list of arguments
      callback: function invoked when LiteTouch acknowledges command (optional)
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.send = function() {
      var args, callback, cmd, out;
      cmd = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      callback = typeof args[args.length - 1] === 'function' ? args.pop() : void 0;
      this.once(cmd, function(msg) {
        if (callback) {
          return callback(null, msg);
        }
      });
      out = "R," + cmd;
      if (args.length > 0) {
        out = "" + out + "," + (args.join(','));
      }
      return this.socket.write("" + out + "\r");
    };

    /*
      Public: Enable notification of events such as combinations, timers, and button presses, LED updates, Module Updates, etc.
      These settings are mutually exclusive – i.e. you can’t have both 3 and 5.
    
      level:  0 - Turn off notification
              1 - Enable Internal (User (Combination and Startup) and Timer Event) notification
              2 - Enable Internal, Switch, and LED Update notification (Maintain compatibility.)
              3 - Enable Switch (Press / Hold / Release) notification
              4 - Enable LED Update notification
              5 - Enable Module Update notification
              6 - Reserved
              7 - Enable all implemented notifications (Combination/Timer, Trigger, LED, Module, etc.)
      callback: function invoked when LiteTouch acknowledges command (optional)
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.internalEventNotify = function(level, callback) {
      if (!(level >= 0 && level <= 7)) {
        return callback(new Error('level must be >=0 and <= 7'));
      }
      return this.send('SIEVN', level, callback);
    };

    /*
      Public: Enable notification of station events and/or LED updates for a station. This does not enable notification
      of combinations and timers.
    
      station: Integer station address
      level:   0 - Turn off notification
               1 - Enable Switch press/hold/release notification
               2 - Enable LED update notification
               3 - Enable both Switch press/hold/release and LED update notification
      callback: function invoked when LiteTouch acknowledges command (optional)
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.stationNotify = function(station, level, callback) {
      if (!(level >= 0 && level <= 4)) {
        return callback(new Error('level must be >=0 and <= 3'));
      }
      return this.send('SSTNN', pad(station), level, callback);
    };

    /*
      Public: Enable notification of state or level change events for a module.
    
      module: Integer module address
      level: 0 - Turn off notification
             1 - Enable Load State and Level notification
      callback: function invoked when LiteTouch acknowledges command (optional)
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.moduleNotify = function(module, level, callback) {
      if (!(level >= 0 && level <= 1)) {
        return callback(new Error('level must be >=0 and <= 1'));
      }
      return this.send('SMODN', pad(module), level, callback);
    };

    /*
      Public: Requests the date-time.
    
      callback: function invoked with a single parameter containing the clock's Date
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.getClock = function(callback) {
      return this.send('DGCLK', function(err, msg) {
        var date, day, hour, minute, month, second, year;
        if (err) {
          return callback(err);
        }
        date = msg[0];
        year = date.substr(0, 4);
        month = parseInt(date.substr(4, 2)) - 1;
        day = date.substr(6, 2);
        hour = date.substr(8, 2);
        minute = date.substr(10, 2);
        second = date.substr(12, 2);
        return callback(null, new Date(year, month, day, hour, minute, second, '00'));
      });
    };

    /*
      Public: Sets the clock with the specified date-time.
    
      date: Date used to set the clock
      callback: function invoked when LiteTouch acknowledges command (optional)
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.setClock = function(date, callback) {
      var day, hour, minute, month, second, year;
      year = date.getFullYear();
      month = ("0" + (date.getMonth() + 1)).slice(-2);
      day = ("0" + (date.getDate())).slice(-2);
      hour = ("0" + (date.getHours())).slice(-2);
      minute = ("0" + (date.getMinutes())).slice(-2);
      second = ("0" + (date.getSeconds())).slice(-2);
      return this.send('DSCLK', "" + year + month + day + hour + minute + second, callback);
    };

    /*
      Public: Returns the time sunrise will occur for this day.
    
      callback: function invoked two parameters - err if an error occured while making the call,
                an object describing the hour and minute of sunrise.
    
      Returns true if command is sent, otherwise false.
    */


    sunriseRegex = /Sunrise at \[(\d{2})(\d{2})\]/;

    astroTimeRegex = /Astro Time is \[(\d{2})(\d{2})\]/;

    localTimeRegex = /Local Time is \[(\d{2})(\d{2})\]/;

    LiteTouch.prototype.getSunrise = function(callback) {
      return this.send('CGTSR', function(err, msg) {
        var astroMatch, localMatch, sunrise, sunriseMatch;
        if (err) {
          return callback(err);
        }
        msg = msg.toString();
        sunrise = {};
        sunriseMatch = msg.match(sunriseRegex);
        if (sunriseMatch) {
          sunrise.sunrise = {
            hour: sunriseMatch[1],
            minute: sunriseMatch[2]
          };
        }
        astroMatch = msg.match(astroTimeRegex);
        if (astroMatch) {
          sunrise.astroTime = {
            hour: astroMatch[1],
            minute: astroMatch[2]
          };
        }
        localMatch = msg.match(localTimeRegex);
        if (localMatch) {
          sunrise.localTime = {
            hour: localMatch[1],
            minute: localMatch[2]
          };
        }
        if (sunrise.length < 3) {
          return callback(new Error('could not parse response'));
        } else {
          return callback(null, sunrise);
        }
      });
    };

    /*
      Public: Returns the time sunset will occur for this day.
    
      callback: function invoked two parameters - err if an error occured while making the call,
                an object describing the hour and minute of sunset.
    
      Returns true if command is sent, otherwise false.
    */


    sunsetRegex = /Sunset at \[(\d{2})(\d{2})\]/;

    LiteTouch.prototype.getSunset = function(callback) {
      return this.send('CGTSS', function(err, msg) {
        var astroMatch, localMatch, sunset, sunsetMatch;
        if (err) {
          return callback(err);
        }
        msg = msg.toString();
        sunset = {};
        sunsetMatch = msg.match(sunsetRegex);
        if (sunsetMatch) {
          sunset.sunset = {
            hour: sunsetMatch[1],
            minute: sunsetMatch[2]
          };
        }
        astroMatch = msg.match(astroTimeRegex);
        if (astroMatch) {
          sunset.astroTime = {
            hour: astroMatch[1],
            minute: astroMatch[2]
          };
        }
        localMatch = msg.match(localTimeRegex);
        if (localMatch) {
          sunset.localTime = {
            hour: localMatch[1],
            minute: localMatch[2]
          };
        }
        if (sunset.length < 3) {
          return callback(new Error('could not parse response'));
        } else {
          return callback(null, sunset);
        }
      });
    };

    /*
      Public: Returns the levels of all loads on a module.
    
      module: integer module number to query
      callback: function invoked with two parameters - err if an error occurred while
                making the call, an array of objects describing the levels of each load
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.getModuleLevels = function(module, callback) {
      return this.send('DGMLV', hex(module), function(err, msg) {
        var i, level, levels, states;
        if (err) {
          return callback(err);
        }
        states = parseInt(msg.shift(), 16).toString(2).split('');
        levels = (function() {
          var _i, _len, _results;
          _results = [];
          for (i = _i = 0, _len = msg.length; _i < _len; i = ++_i) {
            level = msg[i];
            _results.push({
              on: states[i] === '1',
              level: parseInt(level)
            });
          }
          return _results;
        })();
        return callback(null, levels);
      });
    };

    /*
      Public: Connect to the LiteTouch controller.
    */


    LiteTouch.create = function(ip, port) {
      var lt, socket;
      if (port == null) {
        port = 10001;
      }
      socket = new Socket({
        fd: 'tcp4'
      });
      lt = new LiteTouch(socket);
      socket.connect(port, ip);
      return lt;
    };

    return LiteTouch;

  })(EventEmitter);

  module.exports = LiteTouch;

}).call(this);
