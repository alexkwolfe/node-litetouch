// Generated by CoffeeScript 1.4.0
(function() {
  var BufferStream, EventEmitter, LiteTouch, Socket, ack, hex, pad,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  BufferStream = require('bufferstream');

  EventEmitter = require('events').EventEmitter;

  Socket = require('net').Socket;

  ack = ['RSACK', 'RCACK', 'RQRES'];

  hex = function(num) {
    return pad(num.toString(16).toUpperCase());
  };

  pad = function(num) {
    num = num.toString();
    while (num.length < 3) {
      num = "0" + num;
    }
    return num;
  };

  LiteTouch = (function(_super) {
    var astroTimeRegex, localTimeRegex, sunriseRegex, sunsetRegex;

    __extends(LiteTouch, _super);

    function LiteTouch(socket) {
      var _this = this;
      this.socket = socket;
      this.handleData = __bind(this.handleData, this);

      this.buffer = new BufferStream({
        encoding: 'utf8',
        size: 'flexible'
      });
      this.buffer.split('\r', function(message) {
        return _this.handleMessage(message.toString('ascii'));
      });
      this.socket.on('data', this.handleData);
    }

    LiteTouch.prototype.handleData = function(data) {
      return this.buffer.write(data.toString('ascii'));
    };

    LiteTouch.prototype.handleMessage = function(msg) {
      var cmd, parts, type;
      parts = msg.split(',');
      parts.shift();
      type = parts.shift();
      cmd = parts.shift();
      return this.emit(cmd, parts);
    };

    /*
      Internal: Send a command to the LiteTouch controller.
    
      cmd: String command to send (i.e. SIEVN)
      args: list of arguments
      callback: function invoked when LiteTouch acknowledges command (optional)
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.send = function() {
      var args, callback, cmd, out;
      cmd = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      callback = typeof args[args.length - 1] === 'function' ? args.pop() : void 0;
      this.once(cmd, function(msg) {
        if (callback) {
          return callback(null, msg);
        }
      });
      out = "R," + cmd;
      if (args.length > 0) {
        out = "" + out + "," + (args.join(','));
      }
      return this.socket.write("" + out + "\r");
    };

    /*
      Public: Enable notification of events such as combinations, timers, and button presses, LED updates, Module Updates, etc.
      These settings are mutually exclusive – i.e. you can’t have both 3 and 5.
    
      level:  0 - Turn off notification
              1 - Enable Internal (User (Combination and Startup) and Timer Event) notification
              2 - Enable Internal, Switch, and LED Update notification (Maintain compatibility.)
              3 - Enable Switch (Press / Hold / Release) notification
              4 - Enable LED Update notification
              5 - Enable Module Update notification
              6 - Reserved
              7 - Enable all implemented notifications (Combination/Timer, Trigger, LED, Module, etc.)
      callback: function invoked when LiteTouch acknowledges command (optional)
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.internalEventNotify = function(level, callback) {
      if (!(level >= 0 && level <= 7)) {
        return callback(new Error('level must be >=0 and <= 7'));
      }
      return this.send('SIEVN', level, callback);
    };

    /*
      Public: Enable notification of station events and/or LED updates for a station. This does not enable notification
      of combinations and timers.
    
      station: Integer station address
      level:   0 - Turn off notification
               1 - Enable Switch press/hold/release notification
               2 - Enable LED update notification
               3 - Enable both Switch press/hold/release and LED update notification
      callback: function invoked when LiteTouch acknowledges command (optional)
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.stationNotify = function(station, level, callback) {
      if (!(level >= 0 && level <= 4)) {
        return callback(new Error('level must be >=0 and <= 3'));
      }
      return this.send('SSTNN', pad(station), level, callback);
    };

    /*
      Public: Enable notification of state or level change events for a module.
    
      module: Integer module address
      level: 0 - Turn off notification
             1 - Enable Load State and Level notification
      callback: function invoked when LiteTouch acknowledges command (optional)
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.moduleNotify = function(module, level, callback) {
      if (!(level >= 0 && level <= 1)) {
        return callback(new Error('level must be >=0 and <= 1'));
      }
      return this.send('SMODN', pad(module), level, callback);
    };

    /*
      Public: Requests the date-time.
    
      callback: function invoked with a single parameter containing the clock's Date
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.getClock = function(callback) {
      return this.send('DGCLK', function(err, msg) {
        var date, day, hour, minute, month, second, year;
        if (err) {
          return callback(err);
        }
        date = msg[0];
        year = date.substr(0, 4);
        month = parseInt(date.substr(4, 2)) - 1;
        day = date.substr(6, 2);
        hour = date.substr(8, 2);
        minute = date.substr(10, 2);
        second = date.substr(12, 2);
        return callback(null, new Date(year, month, day, hour, minute, second, '00'));
      });
    };

    /*
      Public: Sets the clock with the specified date-time.
    
      date: Date used to set the clock
      callback: function invoked when LiteTouch acknowledges command (optional)
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.setClock = function(date, callback) {
      var day, hour, minute, month, second, year;
      year = date.getFullYear();
      month = ("0" + (date.getMonth() + 1)).slice(-2);
      day = ("0" + (date.getDate())).slice(-2);
      hour = ("0" + (date.getHours())).slice(-2);
      minute = ("0" + (date.getMinutes())).slice(-2);
      second = ("0" + (date.getSeconds())).slice(-2);
      return this.send('DSCLK', "" + year + month + day + hour + minute + second, callback);
    };

    /*
      Public: Returns the time sunrise will occur for this day.
    
      callback: function invoked two parameters - err if an error occured while making the call,
                an object describing the hour and minute of sunrise.
    
      Returns true if command is sent, otherwise false.
    */


    sunriseRegex = /Sunrise at \[(\d{2})(\d{2})\]/;

    astroTimeRegex = /Astro Time is \[(\d{2})(\d{2})\]/;

    localTimeRegex = /Local Time is \[(\d{2})(\d{2})\]/;

    LiteTouch.prototype.getSunrise = function(callback) {
      return this.send('CGTSR', function(err, msg) {
        var astroMatch, localMatch, sunrise, sunriseMatch;
        if (err) {
          return callback(err);
        }
        msg = msg.toString();
        sunrise = {};
        sunriseMatch = msg.match(sunriseRegex);
        if (sunriseMatch) {
          sunrise.sunrise = {
            hour: sunriseMatch[1],
            minute: sunriseMatch[2]
          };
        }
        astroMatch = msg.match(astroTimeRegex);
        if (astroMatch) {
          sunrise.astroTime = {
            hour: astroMatch[1],
            minute: astroMatch[2]
          };
        }
        localMatch = msg.match(localTimeRegex);
        if (localMatch) {
          sunrise.localTime = {
            hour: localMatch[1],
            minute: localMatch[2]
          };
        }
        if (sunrise.length < 3) {
          return callback(new Error('could not parse response'));
        } else {
          return callback(null, sunrise);
        }
      });
    };

    /*
      Public: Returns the time sunset will occur for this day.
    
      callback: function invoked two parameters - err if an error occured while making the call,
                an object describing the hour and minute of sunset.
    
      Returns true if command is sent, otherwise false.
    */


    sunsetRegex = /Sunset at \[(\d{2})(\d{2})\]/;

    LiteTouch.prototype.getSunset = function(callback) {
      return this.send('CGTSS', function(err, msg) {
        var astroMatch, localMatch, sunset, sunsetMatch;
        if (err) {
          return callback(err);
        }
        msg = msg.toString();
        sunset = {};
        sunsetMatch = msg.match(sunsetRegex);
        if (sunsetMatch) {
          sunset.sunset = {
            hour: sunsetMatch[1],
            minute: sunsetMatch[2]
          };
        }
        astroMatch = msg.match(astroTimeRegex);
        if (astroMatch) {
          sunset.astroTime = {
            hour: astroMatch[1],
            minute: astroMatch[2]
          };
        }
        localMatch = msg.match(localTimeRegex);
        if (localMatch) {
          sunset.localTime = {
            hour: localMatch[1],
            minute: localMatch[2]
          };
        }
        if (sunset.length < 3) {
          return callback(new Error('could not parse response'));
        } else {
          return callback(null, sunset);
        }
      });
    };

    /*
      Public: Returns the levels of all loads on a module.
    
      module: integer module number to query
      callback: function invoked with two parameters - err if an error occurred while
                making the call, an array of objects describing the levels of each load
    
      Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.getModuleLevels = function(module, callback) {
      return this.send('DGMLV', hex(module), function(err, msg) {
        var i, level, levels, states;
        if (err) {
          return callback(err);
        }
        states = parseInt(msg.shift(), 16).toString(2).split('');
        levels = (function() {
          var _i, _len, _results;
          _results = [];
          for (i = _i = 0, _len = msg.length; _i < _len; i = ++_i) {
            level = msg[i];
            _results.push({
              on: states[i] === '1',
              level: parseInt(level)
            });
          }
          return _results;
        })();
        return callback(null, levels);
      });
    };

    /*
      Public: Connect to the LiteTouch controller.
    */


    LiteTouch.create = function(ip, port) {
      var lt, socket;
      if (port == null) {
        port = 10001;
      }
      socket = new Socket({
        fd: 'tcp4'
      });
      lt = new LiteTouch(socket);
      socket.connect(port, ip);
      return lt;
    };

    return LiteTouch;

  })(EventEmitter);

  module.exports = LiteTouch;

}).call(this);
