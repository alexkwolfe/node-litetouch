// Generated by CoffeeScript 1.6.2
(function() {
  var BufferStream, EventEmitter, LiteTouch, Socket, acknowlegements, hex, pad,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  BufferStream = require('bufferstream');

  EventEmitter = require('events').EventEmitter;

  Socket = require('net').Socket;

  acknowlegements = ['RSACK', 'RCACK', 'RQRES'];

  hex = function(num) {
    return pad(num.toString(16).toUpperCase());
  };

  pad = function(num) {
    num = num.toString();
    while (num.length < 3) {
      num = "0" + num;
    }
    return num;
  };

  LiteTouch = (function(_super) {
    var astroTimeRegex, localTimeRegex, sunriseRegex, sunsetRegex;

    __extends(LiteTouch, _super);

    function LiteTouch(stream) {
      var _this = this;

      this.stream = stream;
      this.readStream = __bind(this.readStream, this);
      this.buffer = new BufferStream({
        encoding: 'utf8',
        size: 'flexible'
      });
      this.buffer.split('\r', function(message) {
        return _this.handleMessage(message.toString('ascii'));
      });
      this.readStream();
      this.stream.on('readable', this.readStream);
    }

    /*
    Internal: Handle a chunk of data sent by the LiteTouch controller by writing it to the buffer.
    */


    LiteTouch.prototype.readStream = function() {
      var data;

      data = this.stream.read();
      if (data) {
        return this.buffer.write(data.toString('ascii'));
      }
    };

    /*
    Internal: A message has been received and must be handled. Messages acknowledging a command or responding to
    a query are emitted with the command as the event name and the additional payload as the event contents. Messages
    announching an event notification, LED update, or module update are also emitted.
    
    msg: String message sent by the LiteTouch controller.
    */


    LiteTouch.prototype.handleMessage = function(msg) {
      var cmd, parts, type;

      parts = msg.split(',');
      parts.shift();
      type = parts.shift();
      cmd = parts.shift();
      if (__indexOf.call(acknowlegements, type) >= 0) {
        return this.emit(cmd, parts);
      } else if (type === 'REVNT') {
        return this.handleEventNotification(cmd, parts);
      } else if (type === 'RLEDU') {
        return this.handleLEDUpdateNotification(cmd, parts);
      } else if (type === 'RMODU') {
        return this.handleModuleUpdateNotification(cmd, parts);
      }
    };

    /*
    Internal: An event notfication has been sent by the LiteTouch controller. Convert the notification into
    an emitted event.
    
    Switch notifications result in a press, release, or hold event for the station and switch. Switch numbers
    are 1-based, so the first switch is numbered 1, the second is numbered 2, and so forth.
    
    Example node.js event names for "event notifications":
    
      press:2,5   => switch #5 on station #2 was pressed
      release:2,5 => switch #5 on station #2 was released
      hold:3,1    => switch #1 on station #2 was held
    */


    LiteTouch.prototype.handleEventNotification = function(cmd, parts) {
      var button, station;

      if (cmd === 'SWP' || cmd === 'SWR' || cmd === 'SWH') {
        cmd = cmd === 'SWP' ? 'press' : cmd === 'SWR' ? 'release' : cmd === 'SWH' ? 'hold' : void 0;
        station = parseInt(parts[0].substr(0, 3), 16);
        button = parseInt(parts[0].substr(3, 1), 10);
        return this.emit("" + cmd + ":" + station + "," + button);
      } else if (cmd === 'TMB' || cmd === 'TME') {
        return this.emit("timer:" + parts[0]);
      } else if (cmd === 'USR') {
        return this.emit("user:" + parts[0]);
      }
    };

    /*
    Internal: An LED update notification has been sent by the LiteTouch controller. Convert the notification
    into an emitted event.
    
    LED update notifications for a station result in an led event for the station with an Array of Booleans describing
    the whether the LED of each switch is on.
    
    Example node.js events for LED notifications:
    
      led:5, [false,true,false,false,true,false,false,false,false,false,false,false,false,false,false] 
        => LEDs on station 5 were updated. LEDs on switch 2 and 5 are on. 
      
      led:1, [true,true,false,false,false,false,false,false,false,false,false,false,false,false,false]
        => LEDs on station 1 were updated. LEDS on switch 1 and 2 are on.
    */


    LiteTouch.prototype.handleLEDUpdateNotification = function(cmd, parts) {
      var bitmap, station;

      station = parseInt(cmd, 10);
      bitmap = parts.shift().split('').map(function(bit) {
        return bit === '1';
      });
      return this.emit("led:" + station, bitmap);
    };

    /*
    Internal: A module update notification has been sent by the LiteTouch controller. Convert the notification
    into an emitted event.
    
    Module update notification indicate that loads have changed levels (lights were dimmed, turned on or off, etc).
    These notifications for a module result in a loads event for the module with an Array of Integers describing
    the current percentage level of loads attached to the module.
    
    Loads that have not changed levels are represented in the Array with a null value.
    
    Example node.js event for a module update:
    
      loads:5, [0,100,30,null,10,null,30,null]
        => Load state has chnaged on module 5. Load 1 is off. Load 2, 3, 5, and 6 are at 100%, 30%, 10% and 30% respectively.
           Load 4, 6, and 8 did not change levels.
    */


    LiteTouch.prototype.handleModuleUpdateNotification = function(cmd, parts) {
      var changed, levels, module;

      module = parseInt(cmd, 10);
      changed = parseInt(parts.shift(), 16).toString(2).split('');
      changed = changed.map(function(bit) {
        return bit === '1';
      });
      levels = parts.map(function(level) {
        if (level === '-1') {
          return null;
        } else {
          return parseInt(level, 10);
        }
      });
      return this.emit("loads:" + module, levels);
    };

    /*
    Internal: Send a command to the LiteTouch controller.
    
    cmd: String command to send (i.e. SIEVN)
    args: list of arguments
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.send = function() {
      var args, callback, cmd, out;

      cmd = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      callback = typeof args[args.length - 1] === 'function' ? args.pop() : void 0;
      this.once(cmd, function(msg) {
        if (callback) {
          return callback(null, msg);
        }
      });
      out = ['R', cmd].concat(args).join(',');
      return this.stream.write("" + out + "\r");
    };

    /*
    Public: Enable notification of events such as combinations, timers, and button presses, LED updates, Module Updates, etc.
    These settings are mutually exclusive – i.e. you can’t have both 3 and 5.
    
    level:  0 - Turn off notification
            1 - Enable Internal (User (Combination and Startup) and Timer Event) notification
            2 - Enable Internal, Switch, and LED Update notification (Maintain compatibility.)
            3 - Enable Switch (Press / Hold / Release) notification
            4 - Enable LED Update notification
            5 - Enable Module Update notification
            6 - Reserved
            7 - Enable all implemented notifications (Combination/Timer, Trigger, LED, Module, etc.)
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.internalEventNotify = function(level, callback) {
      if (!(level >= 0 && level <= 7)) {
        return callback(new Error('level must be >= 0 and <= 7'));
      }
      return this.send('SIEVN', level, callback);
    };

    /*
    Public: Enable notification of station events and/or LED updates for a station. This does not enable notification
    of combinations and timers.
    
    station: Integer station address
    level:   0 - Turn off notification
             1 - Enable Switch press/hold/release notification
             2 - Enable LED update notification
             3 - Enable both Switch press/hold/release and LED update notification
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.stationNotify = function(station, level, callback) {
      if (!(level >= 0 && level <= 4)) {
        return callback(new Error('level must be >= 0 and <= 3'));
      }
      return this.send('SSTNN', pad(station), level, callback);
    };

    /*
    Public: Enable notification of state or level change events for a module.
    
    module: Integer module address
    level: 0 - Turn off notification
           1 - Enable Load State and Level notification
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.moduleNotify = function(module, level, callback) {
      if (!(level >= 0 && level <= 1)) {
        return callback(new Error('level must be >= 0 and <= 1'));
      }
      return this.send('SMODN', pad(module), level, callback);
    };

    /*
    Public: Requests the date-time.
    
    callback: function invoked with a single parameter containing the clock's Date
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.getClock = function(callback) {
      return this.send('DGCLK', function(err, msg) {
        var date, day, hour, minute, month, second, year;

        if (err) {
          return callback(err);
        }
        date = msg[0];
        year = date.substr(0, 4);
        month = parseInt(date.substr(4, 2), 10) - 1;
        day = date.substr(6, 2);
        hour = date.substr(8, 2);
        minute = date.substr(10, 2);
        second = date.substr(12, 2);
        return callback(null, new Date(year, month, day, hour, minute, second, '00'));
      });
    };

    /*
    Public: Sets the clock with the specified date-time.
    
    date: Date used to set the clock
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.setClock = function(date, callback) {
      var day, hour, minute, month, second, year;

      year = date.getFullYear();
      month = ("0" + (date.getMonth() + 1)).slice(-2);
      day = ("0" + (date.getDate())).slice(-2);
      hour = ("0" + (date.getHours())).slice(-2);
      minute = ("0" + (date.getMinutes())).slice(-2);
      second = ("0" + (date.getSeconds())).slice(-2);
      return this.send('DSCLK', "" + year + month + day + hour + minute + second, callback);
    };

    /*
    Public: Returns the time sunrise will occur for this day.
    
    callback: function invoked two parameters - err if an error occured while making the call,
              an object describing the hour and minute of sunrise.
    
    Returns true if command is sent, otherwise false.
    */


    sunriseRegex = /Sunrise at \[(\d{2})(\d{2})\]/;

    astroTimeRegex = /Astro Time is \[(\d{2})(\d{2})\]/;

    localTimeRegex = /Local Time is \[(\d{2})(\d{2})\]/;

    LiteTouch.prototype.getSunrise = function(callback) {
      return this.send('CGTSR', function(err, msg) {
        var astroMatch, localMatch, sunrise, sunriseMatch;

        if (err) {
          return callback(err);
        }
        msg = msg.toString();
        sunrise = {};
        sunriseMatch = msg.match(sunriseRegex);
        if (sunriseMatch) {
          sunrise.sunrise = {
            hour: sunriseMatch[1],
            minute: sunriseMatch[2]
          };
        }
        astroMatch = msg.match(astroTimeRegex);
        if (astroMatch) {
          sunrise.astroTime = {
            hour: astroMatch[1],
            minute: astroMatch[2]
          };
        }
        localMatch = msg.match(localTimeRegex);
        if (localMatch) {
          sunrise.localTime = {
            hour: localMatch[1],
            minute: localMatch[2]
          };
        }
        if (sunrise.length < 3) {
          return callback(new Error('could not parse response'));
        } else {
          return callback(null, sunrise);
        }
      });
    };

    /*
    Public: Returns the time sunset will occur for this day.
    
    callback: function invoked two parameters - err if an error occured while making the call,
              an object describing the hour and minute of sunset.
    
    Returns true if command is sent, otherwise false.
    */


    sunsetRegex = /Sunset at \[(\d{2})(\d{2})\]/;

    LiteTouch.prototype.getSunset = function(callback) {
      return this.send('CGTSS', function(err, msg) {
        var astroMatch, localMatch, sunset, sunsetMatch;

        if (err) {
          return callback(err);
        }
        msg = msg.toString();
        sunset = {};
        sunsetMatch = msg.match(sunsetRegex);
        if (sunsetMatch) {
          sunset.sunset = {
            hour: sunsetMatch[1],
            minute: sunsetMatch[2]
          };
        }
        astroMatch = msg.match(astroTimeRegex);
        if (astroMatch) {
          sunset.astroTime = {
            hour: astroMatch[1],
            minute: astroMatch[2]
          };
        }
        localMatch = msg.match(localTimeRegex);
        if (localMatch) {
          sunset.localTime = {
            hour: localMatch[1],
            minute: localMatch[2]
          };
        }
        if (sunset.length < 3) {
          return callback(new Error('could not parse response'));
        } else {
          return callback(null, sunset);
        }
      });
    };

    /*
    Public: Returns the levels of all loads on a module.
    
    module: integer module address to query
    callback: function invoked with two parameters - err if an error occurred while
              making the call, an array of objects describing the levels of each load
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.getModuleLevels = function(module, callback) {
      return this.send('DGMLV', hex(module), function(err, msg) {
        var i, level, levels, states;

        if (err) {
          return callback(err);
        }
        states = parseInt(msg.shift(), 16).toString(2).split('');
        levels = (function() {
          var _i, _len, _results;

          _results = [];
          for (i = _i = 0, _len = msg.length; _i < _len; i = ++_i) {
            level = msg[i];
            _results.push({
              on: states[i] === '1',
              level: parseInt(level, 10)
            });
          }
          return _results;
        })();
        return callback(null, levels);
      });
    };

    /*
    Public: Generates a switch press.
    
    station: Integer station address
    switch: Integer switch number (one-based numbered left to right on the switch face)
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.pressSwitch = function(station, swtch, callback) {
      return this._commandSwitch('CPRSW', station, swtch, callback);
    };

    /*
    Public: Generates a switch hold.
    
    station: Integer station address
    switch: Integer switch number (one-based numbered left to right on the switch face)
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.holdSwitch = function(station, swtch, callback) {
      return this._commandSwitch('CHDSW', station, swtch, callback);
    };

    /*
    Public: Generates a switch release.
    
    station: Integer station address
    switch: Integer switch number (one-based numbered left to right on the switch face)
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.releaseSwitch = function(station, swtch, callback) {
      return this._commandSwitch('CRLSW', station, swtch, callback);
    };

    /*
    Public: Generates a switch press followed by a switch release.
    
    station: Integer station address
    switch: Integer switch number (one-based numbered left to right on the switch face)
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.toggleSwitch = function(station, swtch, callback) {
      return this._commandSwitch('CTGSW', station, swtch, callback);
    };

    /*
    Public: Generates a switch press then 0.4 seconds later a hold event.
    
    station: Integer station address
    switch: Integer switch number (one-based numbered left to right on the switch face)
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.pressHoldSwitch = function(station, swtch, callback) {
      return this._commandSwitch('CPHSW', station, swtch, callback);
    };

    /*
    Public: Toggles the loads in the specified load group. If the specified group consists of multiple loads at
    indeterminate states, all loads in the group will first be turned on. The next Toggle Loads On command will turn
    the loads off.
    
    loadGroup: The load group number
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.toggleLoadsOn = function(loadGroup, callback) {
      return this.send('CTLON', pad(loadGroup), callback);
    };

    /*
    Public: Toggles the loads in the specified load group off. If the specified group consists of multiple loads
    at indeterminate states, all loads in the group will first be turned off. The next ToggleLoadsOff command will turn
    the loads on.
    
    loadGroup: The load group number
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.toggleLoadsOff = function(loadGroup, callback) {
      return this.send('CTLOF', pad(loadGroup), callback);
    };

    /*
    Public: Starts ramping the loads in the specified load group.
    
    loadGroup: The load group number
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.startRamp = function(loadGroup, callback) {
      return this.send('CSTRP', pad(loadGroup), callback);
    };

    /*
    Public: Stops ramping the loads in the specified load group and leaves them on at the present levels.
    
    loadGroup: The load group number
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.stopRamp = function(loadGroup, callback) {
      return this.send('CSPRP', pad(loadGroup), callback);
    };

    /*
    Public: Starts ramping the loads in the specified load group down to the min level
    
    loadGroup: The load group number
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.startRampToMin = function(loadGroup, callback) {
      return this.send('CSRMN', pad(loadGroup), callback);
    };

    /*
    Public: Starts ramping the loads in the specified load group up to the max level
    
    loadGroup: The load group number
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.startRampToMax = function(loadGroup, callback) {
      return this.send('CSRMX', pad(loadGroup), callback);
    };

    /*
    Public: Locks the loads in the specified load group. This makes this load group inoperable from any
    source until it is unlocked.
    
    loadGroup: The load group number
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.lockLoads = function(loadGroup, callback) {
      return this.send('CLCKL', pad(loadGroup), callback);
    };

    /*
    Public: Unlocks the loads in the specified load group. This releases control of the load group, making it
    operable from all sources
    
    loadGroup: The load group number
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.unlockLoads = function(loadGroup, callback) {
      return this.send('CUNLL', pad(loadGroup), callback);
    };

    /*
    Public: Locks the specified switch making it inoperable to press, hold, or release commands until unlocked.
    
    station: Integer station address
    switch: Integer switch number (one-based numbered left to right on the switch face)
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.lockSwitch = function(station, swtch, callback) {
      return this._commandSwitch('CLCKS', station, swtch, callback);
    };

    /*
    Public: Unlocks the specified switch.
    
    station: Integer station address
    switch: Integer switch number (one-based numbered left to right on the switch face)
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.unlockSwitch = function(station, swtch, callback) {
      return this._commandSwitch('CUNLS', station, swtch, callback);
    };

    /*
    Public: Locks the timer making it inoperable until unlocked.
    
    timer: the timer ID
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.lockTimer = function(timer, callback) {
      return this.send('CLCKT', pad(timer), callback);
    };

    /*
    Public: Unlocks the specified timer.
    
    timer: the timer ID
    callback: function invoked when LiteTouch acknowledges command (optional)
    
    Returns true if command is sent, otherwise false.
    */


    LiteTouch.prototype.unlockTimer = function(timer, callback) {
      return this.send('CUNLT', pad(timer), callback);
    };

    /*
    Internal: Send a switch command.
    */


    LiteTouch.prototype._commandSwitch = function(cmd, station, swtch, callback) {
      swtch = parseInt(swtch, 10) + 1;
      if (!(swtch >= 1 && swtch <= 8)) {
        return callback(new Error('switch must be >= 1 and <= 8'));
      }
      return this.send(cmd, "" + (pad(station)) + (swtch - 1), callback);
    };

    /*
    Public: Connect to the LiteTouch controller.
    
    ip: String IP address of controller
    port: Integer TCP port of controller (optional, defaults to 10001)
    callback: invoked once the connection has been established (optional)
    */


    LiteTouch.connect = function() {
      var args, callback, ip, lt, port, socket, _ref;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (typeof args[args.length - 1] === 'function') {
        callback = args.pop();
      }
      ip = args.shift();
      port = (_ref = args.shift()) != null ? _ref : 10001;
      socket = new Socket({
        type: 'tcp4'
      });
      lt = new LiteTouch(socket);
      socket.connect(port, ip, callback);
      return lt;
    };

    return LiteTouch;

  })(EventEmitter);

  module.exports = LiteTouch;

}).call(this);
